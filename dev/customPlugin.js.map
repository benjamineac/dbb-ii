{"version":3,"file":"customPlugin.js","sources":["webpack://[name]/webpack/universalModuleDefinition","webpack://[name]/webpack/bootstrap","webpack://[name]/./src/main.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"customPlugin\"] = factory();\n\telse\n\t\troot[\"customPlugin\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"./dev/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/main.js\");\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar MergedInput = function (_Phaser$Plugins$Scene) {\n\t_inherits(MergedInput, _Phaser$Plugins$Scene);\n\n\t/**\n  * The Merged Input plugin is designed to run in the background and handle input.\n  * Upon detecting a keypress or gamepad interaction, the plugin will update a player object and emit global events.\n  *\n  * @extends Phaser.Scene\n  * @param {*} scene\n  * @param {*} pluginManager\n  */\n\tfunction MergedInput(scene, pluginManager) {\n\t\t_classCallCheck(this, MergedInput);\n\n\t\tvar _this = _possibleConstructorReturn(this, (MergedInput.__proto__ || Object.getPrototypeOf(MergedInput)).call(this, scene, pluginManager));\n\n\t\t_this.scene = scene;\n\n\t\t// Players\n\t\t_this.players = [];\n\t\t// Gamepads\n\t\t_this.gamepads = [];\n\t\t// Keys object to store Phaser key objects. We'll check these during update\n\t\t_this.keys = {};\n\n\t\t_this.bearings = {\n\t\t\t'-180': 'W',\n\t\t\t'-168.75': 'WBN',\n\t\t\t'-157.5': 'WNW',\n\t\t\t'-146.25': 'NWBW',\n\t\t\t'-135': 'NW',\n\t\t\t'-123.75': 'NWBN',\n\t\t\t'-112.5': 'NNW',\n\t\t\t'-101.25': 'NBW',\n\t\t\t'-90': 'N',\n\t\t\t'-78.75': 'NBE',\n\t\t\t'-67.5': 'NNE',\n\t\t\t'-56.25': 'NEBN',\n\t\t\t'-45': 'NE',\n\t\t\t'-33.75': 'NEBE',\n\t\t\t'-22.5': 'EBE',\n\t\t\t'-11.25': 'EBN',\n\t\t\t'0': 'E',\n\t\t\t'11.25': 'EBS',\n\t\t\t'22.5': 'ESE',\n\t\t\t'33.75': 'SEBE',\n\t\t\t'45': 'SE',\n\t\t\t'56.25': 'SEBS',\n\t\t\t'67.5': 'SSE',\n\t\t\t'78.75': 'SBE',\n\t\t\t'90': 'S',\n\t\t\t'101.25': 'SBW',\n\t\t\t'112.5': 'SSW',\n\t\t\t'123.75': 'SWBS',\n\t\t\t'135': 'SW',\n\t\t\t'146.25': 'SWBW',\n\t\t\t'157.5': 'WSW',\n\t\t\t'168.75': 'WBS',\n\t\t\t'180': 'W'\n\t\t};\n\t\treturn _this;\n\t}\n\n\t_createClass(MergedInput, [{\n\t\tkey: 'refreshGamepads',\n\t\tvalue: function refreshGamepads() {\n\t\t\t// Sometimes, gamepads are undefined. For some reason.\n\t\t\tthis.gamepads = this.systems.input.gamepad.gamepads.filter(function (el) {\n\t\t\t\treturn el != null;\n\t\t\t});\n\n\t\t\tvar _iteratorNormalCompletion = true;\n\t\t\tvar _didIteratorError = false;\n\t\t\tvar _iteratorError = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator = this.gamepads.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\t\tvar _step$value = _slicedToArray(_step.value, 2),\n\t\t\t\t\t    index = _step$value[0],\n\t\t\t\t\t    thisGamepad = _step$value[1];\n\n\t\t\t\t\tthisGamepad.index = index; // Overwrite the gamepad index, in case we had undefined gamepads earlier\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError = true;\n\t\t\t\t_iteratorError = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t\t_iterator.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'boot',\n\t\tvalue: function boot() {\n\t\t\tthis.eventEmitter = this.systems.events;\n\t\t\tthis.eventEmitter.on('update', this.update, this);\n\n\t\t\t// Gamepad\n\t\t\tif (typeof this.systems.input.gamepad !== 'undefined') {\n\t\t\t\tthis.systems.input.gamepad.once('connected', function (thisGamepad) {\n\t\t\t\t\tthis.refreshGamepads();\n\t\t\t\t\tthis.setupGamepad(thisGamepad);\n\t\t\t\t}, this);\n\n\t\t\t\t// Check to see if the gamepad has already been setup by the browser\n\t\t\t\tthis.systems.input.gamepad.refreshPads();\n\t\t\t\tif (this.systems.input.gamepad.total) {\n\t\t\t\t\tthis.refreshGamepads();\n\t\t\t\t\tvar _iteratorNormalCompletion2 = true;\n\t\t\t\t\tvar _didIteratorError2 = false;\n\t\t\t\t\tvar _iteratorError2 = undefined;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfor (var _iterator2 = this.gamepads[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t\t\t\t\t\t\tvar thisGamepad = _step2.value;\n\n\t\t\t\t\t\t\tthis.systems.input.gamepad.emit('connected', thisGamepad);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t_didIteratorError2 = true;\n\t\t\t\t\t\t_iteratorError2 = err;\n\t\t\t\t\t} finally {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t\t\t\t\t\t\t\t_iterator2.return();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tif (_didIteratorError2) {\n\t\t\t\t\t\t\t\tthrow _iteratorError2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.systems.input.gamepad.on('down', this.gamepadButtonDown, this);\n\t\t\t\tthis.systems.input.gamepad.on('up', this.gamepadButtonUp, this);\n\t\t\t}\n\n\t\t\t// Keyboard\n\t\t\tthis.systems.input.keyboard.on('keydown', function (event) {\n\t\t\t\tvar keyCode = Object.keys(Phaser.Input.Keyboard.KeyCodes).find(function (key) {\n\t\t\t\t\treturn Phaser.Input.Keyboard.KeyCodes[key] === event.keyCode;\n\t\t\t\t});\n\t\t\t\tvar playerIndex = this.getPlayerIndexFromKey(keyCode);\n\t\t\t\tif (playerIndex > -1) {\n\t\t\t\t\tthis.getPlayer(playerIndex).interaction.device = 'keyboard';\n\t\t\t\t}\n\t\t\t}, this);\n\t\t\tthis.systems.input.keyboard.on('keyup', function () {\n\t\t\t\tvar keyCode = Object.keys(Phaser.Input.Keyboard.KeyCodes).find(function (key) {\n\t\t\t\t\treturn Phaser.Input.Keyboard.KeyCodes[key] === event.keyCode;\n\t\t\t\t});\n\t\t\t\tvar playerIndex = this.getPlayerIndexFromKey(keyCode);\n\t\t\t\tif (playerIndex > -1) {\n\t\t\t\t\tthis.getPlayer(playerIndex).interaction.device = 'keyboard';\n\t\t\t\t}\n\t\t\t}, this);\n\n\t\t\t// Pointer\n\t\t\tthis.systems.input.mouse.disableContextMenu();\n\n\t\t\tthis.systems.input.on('pointermove', function (pointer) {\n\t\t\t\tthis.pointerMove(pointer);\n\t\t\t}, this);\n\n\t\t\tthis.systems.input.on('pointerdown', function (pointer) {\n\t\t\t\tthis.pointerDown(pointer);\n\t\t\t}, this);\n\n\t\t\tthis.systems.input.on('pointerup', function (pointer) {\n\t\t\t\tthis.pointerUp(pointer);\n\t\t\t}, this);\n\t\t}\n\t}, {\n\t\tkey: 'update',\n\t\tvalue: function update() {\n\t\t\t// Loop through players and manage buffered input\n\t\t\tvar _iteratorNormalCompletion3 = true;\n\t\t\tvar _didIteratorError3 = false;\n\t\t\tvar _iteratorError3 = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator3 = this.players[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t\t\t\t\tvar thisPlayer = _step3.value;\n\n\t\t\t\t\tif (thisPlayer.interaction.pressed != '') {\n\t\t\t\t\t\tthisPlayer.interaction.buffer = '';\n\t\t\t\t\t}\n\t\t\t\t\tif (thisPlayer.interaction.buffer == '') {\n\t\t\t\t\t\tthisPlayer.interaction.pressed = '';\n\t\t\t\t\t}\n\n\t\t\t\t\t// If the pointer hasn't moved, and the scene has changed, this can end up as undefined\n\t\t\t\t\tthisPlayer.pointer.BEARING = typeof thisPlayer.pointer.BEARING != 'undefined' ? thisPlayer.pointer.BEARING : '';\n\t\t\t\t\tthisPlayer.pointer.BEARING_DEGREES = typeof thisPlayer.pointer.BEARING_DEGREES != 'undefined' ? thisPlayer.pointer.BEARING_DEGREES : 0;\n\t\t\t\t\tthisPlayer.pointer.ANGLE = typeof thisPlayer.pointer.ANGLE != 'undefined' ? thisPlayer.pointer.ANGLE : '';\n\n\t\t\t\t\tthisPlayer.direction.BEARING = this.mapDirectionsToBearing(thisPlayer.direction);\n\t\t\t\t\tthisPlayer.direction.BEARING_LAST = thisPlayer.direction.BEARING != '' ? thisPlayer.direction.BEARING : thisPlayer.direction.BEARING_LAST;\n\t\t\t\t\tthisPlayer.direction.DEGREES = thisPlayer.direction.BEARING != '' ? parseFloat(this.mapBearingToDegrees(thisPlayer.direction.BEARING)) : 0;\n\t\t\t\t\tthisPlayer.direction.DEGREES_LAST = thisPlayer.direction.BEARING_LAST != '' ? parseFloat(this.mapBearingToDegrees(thisPlayer.direction.BEARING_LAST)) : 0;\n\t\t\t\t\tthisPlayer.direction_secondary.BEARING = this.mapDirectionsToBearing(thisPlayer.direction_secondary);\n\t\t\t\t\tthisPlayer.direction_secondary.BEARING_LAST = thisPlayer.direction_secondary.BEARING != '' ? thisPlayer.direction_secondary.BEARING : thisPlayer.direction_secondary.BEARING_LAST;\n\t\t\t\t\tthisPlayer.direction_secondary.DEGREES = thisPlayer.direction_secondary.BEARING != '' ? parseFloat(this.mapBearingToDegrees(thisPlayer.direction_secondary.BEARING)) : 0;\n\t\t\t\t\tthisPlayer.direction_secondary.DEGREES_LAST = thisPlayer.direction_secondary.BEARING_LAST != '' ? parseFloat(this.mapBearingToDegrees(thisPlayer.direction_secondary.BEARING_LAST)) : 0;\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError3 = true;\n\t\t\t\t_iteratorError3 = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t\t\t\t\t\t_iterator3.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError3) {\n\t\t\t\t\t\tthrow _iteratorError3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.checkKeyboardInput();\n\t\t\tthis.checkGamepadInput();\n\t\t\tthis.checkPointerInput();\n\t\t}\n\n\t\t/**\n   * Set up the gamepad and associate with a player object\n   */\n\n\t}, {\n\t\tkey: 'setupGamepad',\n\t\tvalue: function setupGamepad(thisGamepad) {\n\t\t\tthis.eventEmitter.emit('mergedInput', { device: 'gamepad', id: thisGamepad.id, player: thisGamepad.index, action: 'Connected' });\n\n\t\t\tif (typeof this.players[thisGamepad.index] === 'undefined') {\n\t\t\t\tthis.addPlayer();\n\t\t\t}\n\t\t\tthis.players[thisGamepad.index].gamepad = thisGamepad;\n\t\t}\n\n\t\t/**\n   * Add a new player object to the players array\n   * @param {number} index Player index - if a player object at this index already exists, it will be returned instead of creating a new player object\n   */\n\n\t}, {\n\t\tkey: 'addPlayer',\n\t\tvalue: function addPlayer(index) {\n\t\t\tif (_typeof(Number.isInteger(index)) && typeof this.players[index] !== 'undefined') {\n\t\t\t\treturn this.players[index];\n\t\t\t} else {\n\t\t\t\tthis.players.push(this.setupControls());\n\t\t\t\tthis.players[this.players.length - 1].index = this.players.length - 1;\n\t\t\t\treturn this.players[this.players.length - 1];\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Get player object\n   * @param {number} index Player index\n   */\n\n\t}, {\n\t\tkey: 'getPlayer',\n\t\tvalue: function getPlayer(index) {\n\t\t\treturn typeof this.players[index] !== 'undefined' ? this.players[index] : '';\n\t\t}\n\t}, {\n\t\tkey: 'getPlayerIndexFromKey',\n\t\tvalue: function getPlayerIndexFromKey(key) {\n\t\t\tvar _iteratorNormalCompletion4 = true;\n\t\t\tvar _didIteratorError4 = false;\n\t\t\tvar _iteratorError4 = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator4 = this.players[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n\t\t\t\t\tvar thisPlayer = _step4.value;\n\n\t\t\t\t\t// Loop through all the keys assigned to this player\n\t\t\t\t\tfor (var thisKey in thisPlayer.keys) {\n\t\t\t\t\t\tvar _iteratorNormalCompletion5 = true;\n\t\t\t\t\t\tvar _didIteratorError5 = false;\n\t\t\t\t\t\tvar _iteratorError5 = undefined;\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tfor (var _iterator5 = thisPlayer.keys[thisKey][Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n\t\t\t\t\t\t\t\tvar thisValue = _step5.value;\n\n\t\t\t\t\t\t\t\tif (thisValue == key) {\n\t\t\t\t\t\t\t\t\treturn thisPlayer.index;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t_didIteratorError5 = true;\n\t\t\t\t\t\t\t_iteratorError5 = err;\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (!_iteratorNormalCompletion5 && _iterator5.return) {\n\t\t\t\t\t\t\t\t\t_iterator5.return();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\tif (_didIteratorError5) {\n\t\t\t\t\t\t\t\t\tthrow _iteratorError5;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError4 = true;\n\t\t\t\t_iteratorError4 = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion4 && _iterator4.return) {\n\t\t\t\t\t\t_iterator4.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError4) {\n\t\t\t\t\t\tthrow _iteratorError4;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn -1;\n\t\t}\n\n\t\t/**\n   * Returns a struct to hold input control information\n   * Set up a struct for each player in the game\n   * Direction and Buttons contain the input from the devices\n   * The keys struct contains arrays of keyboard characters that will trigger the action\n   */\n\n\t}, {\n\t\tkey: 'setupControls',\n\t\tvalue: function setupControls() {\n\t\t\tvar controls = {\n\t\t\t\t'direction': {\n\t\t\t\t\t'UP': 0,\n\t\t\t\t\t'DOWN': 0,\n\t\t\t\t\t'LEFT': 0,\n\t\t\t\t\t'RIGHT': 0,\n\t\t\t\t\t'BEARING': '',\n\t\t\t\t\t'BEARING_LAST': '',\n\t\t\t\t\t'DEGREES': 0,\n\t\t\t\t\t'DEGREES_LAST': 0,\n\t\t\t\t\t'TIMESTAMP': 0\n\t\t\t\t},\n\t\t\t\t'direction_secondary': {\n\t\t\t\t\t'UP': 0,\n\t\t\t\t\t'DOWN': 0,\n\t\t\t\t\t'LEFT': 0,\n\t\t\t\t\t'RIGHT': 0,\n\t\t\t\t\t'BEARING': '',\n\t\t\t\t\t'DEGREES': 0,\n\t\t\t\t\t'BEARING_LAST': '',\n\t\t\t\t\t'DEGREES_LAST': 0,\n\t\t\t\t\t'TIMESTAMP': 0\n\t\t\t\t},\n\t\t\t\t'buttons': {},\n\t\t\t\t'pointer': {\n\t\t\t\t\t'M1': 0,\n\t\t\t\t\t'M2': 0,\n\t\t\t\t\t'M3': 0,\n\t\t\t\t\t'M4': 0,\n\t\t\t\t\t'M5': 0,\n\t\t\t\t\t'BEARING': '',\n\t\t\t\t\t'BEARING_DEGREES': 0,\n\t\t\t\t\t'ANGLE': 0,\n\t\t\t\t\t'TIMESTAMP': 0\n\t\t\t\t},\n\t\t\t\t'position': {},\n\t\t\t\t'interaction': {},\n\t\t\t\t'gamepad': {},\n\t\t\t\t'keys': {\n\t\t\t\t\t'UP': [],\n\t\t\t\t\t'DOWN': [],\n\t\t\t\t\t'LEFT': [],\n\t\t\t\t\t'RIGHT': []\n\t\t\t\t}\n\t\t\t};\n\t\t\tfor (var i = 1; i <= 16; i++) {\n\t\t\t\tcontrols.buttons['B' + i] = 0;\n\t\t\t\tcontrols.keys['B' + i] = [];\n\t\t\t}\n\n\t\t\tcontrols.interaction.buffer = '';\n\t\t\tcontrols.interaction.pressed = '';\n\t\t\tcontrols.interaction.last = '';\n\t\t\tcontrols.interaction.device = '';\n\n\t\t\treturn controls;\n\t\t}\n\n\t\t// Keyboard functions\n\n\t\t/**\n   * Define a key for a player/action combination\n   * @param {number} player The player on which we're defining a key\n   * @param {string} action The action to define\n   * @param {string} value The key to use\n   * @param {boolean} append When true, this key definition will be appended to the existing key(s) for this action\n   */\n\n\t}, {\n\t\tkey: 'defineKey',\n\t\tvalue: function defineKey() {\n\t\t\tvar player = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\t\t\tvar action = arguments[1];\n\t\t\tvar value = arguments[2];\n\t\t\tvar append = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n\t\t\t// Set up a new player if none defined\n\t\t\tif (typeof this.players[player] === 'undefined') {\n\t\t\t\tthis.addPlayer();\n\t\t\t}\n\n\t\t\tif (['UP', 'DOWN', 'LEFT', 'RIGHT', 'ALT_UP', 'ALT_DOWN', 'ALT_LEFT', 'ALT_RIGHT', 'B0', 'B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B8', 'B9', 'B10', 'B11', 'B12', 'B13', 'B14', 'B15', 'B16'].includes(action)) {\n\t\t\t\tif (append && typeof this.players[player].keys[action] !== 'undefined') {\n\t\t\t\t\tthis.players[player].keys[action].push([value]);\n\t\t\t\t} else {\n\t\t\t\t\tthis.players[player].keys[action] = [];\n\t\t\t\t\tthis.players[player].keys[action].push([value]);\n\t\t\t\t}\n\n\t\t\t\tthis.keys[[value]] = this.systems.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes[value]);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n   * Iterate through players and check for interaction with defined keys\n   */\n\n\t}, {\n\t\tkey: 'checkKeyboardInput',\n\t\tvalue: function checkKeyboardInput() {\n\t\t\t// Loop through players and check for keypresses - use of 'entries()' gives us an index to use for the player\n\t\t\tvar _iteratorNormalCompletion6 = true;\n\t\t\tvar _didIteratorError6 = false;\n\t\t\tvar _iteratorError6 = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator6 = this.players.entries()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n\t\t\t\t\tvar _step6$value = _slicedToArray(_step6.value, 2),\n\t\t\t\t\t    playerIndex = _step6$value[0],\n\t\t\t\t\t    thisPlayer = _step6$value[1];\n\n\t\t\t\t\t// Loop through all the keys assigned to this player\n\t\t\t\t\tfor (var thisKey in thisPlayer.keys) {\n\t\t\t\t\t\tvar action = 0;\n\t\t\t\t\t\tvar _iteratorNormalCompletion7 = true;\n\t\t\t\t\t\tvar _didIteratorError7 = false;\n\t\t\t\t\t\tvar _iteratorError7 = undefined;\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tfor (var _iterator7 = thisPlayer.keys[thisKey][Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n\t\t\t\t\t\t\t\tvar thisValue = _step7.value;\n\n\t\t\t\t\t\t\t\t// Check if the key is down\n\t\t\t\t\t\t\t\taction = this.keys[thisValue].isDown ? 1 : action;\n\n\t\t\t\t\t\t\t\t// Emit events based on the key down and up values\n\t\t\t\t\t\t\t\tif (Phaser.Input.Keyboard.JustDown(this.keys[thisValue])) {\n\t\t\t\t\t\t\t\t\tthis.eventEmitter.emit('mergedInput', { device: 'keyboard', value: 1, player: playerIndex, action: thisKey, state: 'DOWN' });\n\t\t\t\t\t\t\t\t\t// Update the last button state\n\t\t\t\t\t\t\t\t\tthisPlayer.interaction.pressed = thisKey;\n\t\t\t\t\t\t\t\t\tthisPlayer.interaction.buffer = thisKey;\n\t\t\t\t\t\t\t\t\tthisPlayer.interaction.last = thisKey;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (Phaser.Input.Keyboard.JustUp(this.keys[thisValue])) {\n\t\t\t\t\t\t\t\t\tthis.eventEmitter.emit('mergedInput', { device: 'keyboard', value: 1, player: playerIndex, action: thisKey, state: 'UP' });\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Set the action in the player object\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t_didIteratorError7 = true;\n\t\t\t\t\t\t\t_iteratorError7 = err;\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (!_iteratorNormalCompletion7 && _iterator7.return) {\n\t\t\t\t\t\t\t\t\t_iterator7.return();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\tif (_didIteratorError7) {\n\t\t\t\t\t\t\t\t\tthrow _iteratorError7;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (['UP', 'DOWN', 'LEFT', 'RIGHT'].includes(thisKey)) {\n\t\t\t\t\t\t\tthisPlayer.direction[thisKey] = action;\n\t\t\t\t\t\t\tthisPlayer.direction.TIMESTAMP = this.scene.sys.time.now;\n\t\t\t\t\t\t} else if (['ALT_UP', 'ALT_DOWN', 'ALT_LEFT', 'ALT_RIGHT'].includes(thisKey)) {\n\t\t\t\t\t\t\tthisPlayer.direction_secondary[thisKey.replace('ALT_', '')] = action;\n\t\t\t\t\t\t\tif (action == 1) {\n\t\t\t\t\t\t\t\tthisPlayer.direction_secondary.TIMESTAMP = this.scene.sys.time.now;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthisPlayer.buttons[thisKey] = action;\n\t\t\t\t\t\t\tif (action == 1) {\n\t\t\t\t\t\t\t\tthisPlayer.buttons.TIMESTAMP = this.scene.sys.time.now;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Set the latest interaction flag\n\t\t\t\t\t\tif (action == 1) {\n\t\t\t\t\t\t\tthisPlayer.interaction.device = 'keyboard';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError6 = true;\n\t\t\t\t_iteratorError6 = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion6 && _iterator6.return) {\n\t\t\t\t\t\t_iterator6.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError6) {\n\t\t\t\t\t\tthrow _iteratorError6;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Iterate through players and check for interaction with defined pointer buttons\n   */\n\n\t}, {\n\t\tkey: 'checkPointerInput',\n\t\tvalue: function checkPointerInput() {\n\t\t\t// Loop through players and check for button presses - use of 'entries()' gives us an index to use for the player\n\t\t\tvar _iteratorNormalCompletion8 = true;\n\t\t\tvar _didIteratorError8 = false;\n\t\t\tvar _iteratorError8 = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator8 = this.players.entries()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n\t\t\t\t\tvar _step8$value = _slicedToArray(_step8.value, 2),\n\t\t\t\t\t    playerIndex = _step8$value[0],\n\t\t\t\t\t    thisPlayer = _step8$value[1];\n\n\t\t\t\t\t// Loop through all the keys assigned to this player\n\t\t\t\t\tfor (var thisKey in thisPlayer.keys) {\n\t\t\t\t\t\tvar _iteratorNormalCompletion9 = true;\n\t\t\t\t\t\tvar _didIteratorError9 = false;\n\t\t\t\t\t\tvar _iteratorError9 = undefined;\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tfor (var _iterator9 = thisPlayer.keys[thisKey][Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n\t\t\t\t\t\t\t\tvar thisValue = _step9.value;\n\t\t\t\t\t\t\t\t// Each definition for this key action\n\t\t\t\t\t\t\t\tif (['M1', 'M2', 'M3', 'M4', 'M5'].includes(thisValue[0])) {\n\t\t\t\t\t\t\t\t\t// Check to see if button is pressed (stored in P1, can't have two mice...)\n\t\t\t\t\t\t\t\t\tif (this.players[0].pointer[thisValue] == 1) {\n\t\t\t\t\t\t\t\t\t\tthisPlayer.buttons[thisKey] = 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t_didIteratorError9 = true;\n\t\t\t\t\t\t\t_iteratorError9 = err;\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (!_iteratorNormalCompletion9 && _iterator9.return) {\n\t\t\t\t\t\t\t\t\t_iterator9.return();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\tif (_didIteratorError9) {\n\t\t\t\t\t\t\t\t\tthrow _iteratorError9;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError8 = true;\n\t\t\t\t_iteratorError8 = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion8 && _iterator8.return) {\n\t\t\t\t\t\t_iterator8.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError8) {\n\t\t\t\t\t\tthrow _iteratorError8;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Gamepad functions\n\n\t\t/**\n   * When a gamepad button is pressed down, this function will emit a mergedInput event in the global registry.\n   * The event contains a reference to the player assigned to the gamepad, and passes a mapped action and value\n   * @param {number} index Button index\n   * @param {number} value Button value\n   * @param {Phaser.Input.Gamepad.Button} button Phaser Button object\n   */\n\n\t}, {\n\t\tkey: 'gamepadButtonDown',\n\t\tvalue: function gamepadButtonDown(pad, button, value) {\n\t\t\tthis.players[pad.index].interaction.device = 'gamepad';\n\n\t\t\tthis.eventEmitter.emit('mergedInput', { device: 'gamepad', value: value, player: pad.index, action: 'B' + button.index, state: 'DOWN' });\n\n\t\t\t// DPad mapping\n\t\t\tif (button.index === 12) {\n\t\t\t\tthis.eventEmitter.emit('mergedInput', { device: 'gamepad', value: 1, player: pad.index, action: 'UP', state: 'DOWN' });\n\t\t\t}\n\t\t\tif (button.index === 13) {\n\t\t\t\tthis.eventEmitter.emit('mergedInput', { device: 'gamepad', value: 1, player: pad.index, action: 'DOWN', state: 'DOWN' });\n\t\t\t}\n\t\t\tif (button.index === 14) {\n\t\t\t\tthis.eventEmitter.emit('mergedInput', { device: 'gamepad', value: 1, player: pad.index, action: 'LEFT', state: 'DOWN' });\n\t\t\t}\n\t\t\tif (button.index === 15) {\n\t\t\t\tthis.eventEmitter.emit('mergedInput', { device: 'gamepad', value: 1, player: pad.index, action: 'RIGHT', state: 'DOWN' });\n\t\t\t}\n\n\t\t\t// Last button pressed\n\t\t\tif (![12, 13, 14, 15].includes(button.index)) {\n\t\t\t\t// Update the last button state\n\t\t\t\tthis.players[pad.index].interaction.pressed = 'B' + button.index;\n\t\t\t\tthis.players[pad.index].interaction.last = 'B' + button.index;\n\t\t\t\tthis.players[pad.index].interaction.buffer = 'B' + button.index;\n\t\t\t\tthis.players[pad.index].buttons.TIMESTAMP = this.scene.sys.time.now;\n\t\t\t} else {\n\t\t\t\tthis.players[pad.index].direction.TIMESTAMP = this.scene.sys.time.now;\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * When a gamepad button is released, this function will emit a mergedInput event in the global registry.\n   * The event contains a reference to the player assigned to the gamepad, and passes a mapped action and value\n   * @param {number} index Button index\n   * @param {number} value Button value\n   * @param {Phaser.Input.Gamepad.Button} button Phaser Button object\n   */\n\n\t}, {\n\t\tkey: 'gamepadButtonUp',\n\t\tvalue: function gamepadButtonUp(pad, button, value) {\n\t\t\tthis.players[pad.index].interaction.device = 'gamepad';\n\t\t\tthis.eventEmitter.emit('mergedInput', { device: 'gamepad', value: value, player: pad.index, action: 'B' + button.index, state: 'UP' });\n\t\t\t// DPad mapping\n\t\t\tif (button.index === 12) {\n\t\t\t\tthis.eventEmitter.emit('mergedInput', { device: 'gamepad', value: 1, player: pad.index, action: 'UP', state: 'UP' });\n\t\t\t}\n\t\t\tif (button.index === 13) {\n\t\t\t\tthis.eventEmitter.emit('mergedInput', { device: 'gamepad', value: 1, player: pad.index, action: 'DOWN', state: 'UP' });\n\t\t\t}\n\t\t\tif (button.index === 14) {\n\t\t\t\tthis.eventEmitter.emit('mergedInput', { device: 'gamepad', value: 1, player: pad.index, action: 'LEFT', state: 'UP' });\n\t\t\t}\n\t\t\tif (button.index === 15) {\n\t\t\t\tthis.eventEmitter.emit('mergedInput', { device: 'gamepad', value: 1, player: pad.index, action: 'RIGHT', state: 'UP' });\n\t\t\t}\n\n\t\t\tif (![12, 13, 14, 15].includes(button.index)) {\n\t\t\t\t// Update the last button state\n\t\t\t\tthis.players[pad.index].buttons.TIMESTAMP = this.scene.sys.time.now;\n\t\t\t} else {\n\t\t\t\tthis.players[pad.index].direction.TIMESTAMP = this.scene.sys.time.now;\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Iterate through gamepads and handle interactions\n   */\n\n\t}, {\n\t\tkey: 'checkGamepadInput',\n\t\tvalue: function checkGamepadInput() {\n\t\t\t// Check for gamepad input\n\t\t\tvar _iteratorNormalCompletion10 = true;\n\t\t\tvar _didIteratorError10 = false;\n\t\t\tvar _iteratorError10 = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator10 = this.gamepads[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n\t\t\t\t\tvar thisGamepad = _step10.value;\n\n\n\t\t\t\t\t// Set up a player if we don't have one, presumably due to race conditions in detecting gamepads\n\t\t\t\t\tif (typeof this.players[thisGamepad.index] === 'undefined') {\n\t\t\t\t\t\tthis.addPlayer();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Directions\n\t\t\t\t\tif (thisGamepad.leftStick.y < -0.5) {\n\t\t\t\t\t\tthis.players[thisGamepad.index].direction.UP = Math.abs(thisGamepad.leftStick.y);\n\t\t\t\t\t\tthis.players[thisGamepad.index].direction.TIMESTAMP = this.scene.sys.time.now;\n\t\t\t\t\t} else if (thisGamepad.leftStick.y > 0.5) {\n\t\t\t\t\t\tthis.players[thisGamepad.index].direction.DOWN = thisGamepad.leftStick.y;\n\t\t\t\t\t\tthis.players[thisGamepad.index].direction.TIMESTAMP = this.scene.sys.time.now;\n\t\t\t\t\t} else if (this.players[thisGamepad.index].interaction.device === 'gamepad') {\n\t\t\t\t\t\t// DPad\n\t\t\t\t\t\tthis.players[thisGamepad.index].direction.UP = thisGamepad.up ? 1 : 0;\n\t\t\t\t\t\tthis.players[thisGamepad.index].direction.DOWN = thisGamepad.down ? 1 : 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (thisGamepad.leftStick.x < -0.5) {\n\t\t\t\t\t\tthis.players[thisGamepad.index].direction.LEFT = Math.abs(thisGamepad.leftStick.x);\n\t\t\t\t\t\tthis.players[thisGamepad.index].direction.TIMESTAMP = this.scene.sys.time.now;\n\t\t\t\t\t} else if (thisGamepad.leftStick.x > 0.5) {\n\t\t\t\t\t\tthis.players[thisGamepad.index].direction.RIGHT = thisGamepad.leftStick.x;\n\t\t\t\t\t\tthis.players[thisGamepad.index].direction.TIMESTAMP = this.scene.sys.time.now;\n\t\t\t\t\t} else if (this.players[thisGamepad.index].interaction.device === 'gamepad') {\n\t\t\t\t\t\t// DPad\n\t\t\t\t\t\tthis.players[thisGamepad.index].direction.LEFT = thisGamepad.left ? 1 : 0;\n\t\t\t\t\t\tthis.players[thisGamepad.index].direction.RIGHT = thisGamepad.right ? 1 : 0;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Secondary\n\t\t\t\t\tif (thisGamepad.rightStick.y < -0.5) {\n\t\t\t\t\t\tthis.players[thisGamepad.index].direction_secondary.UP = Math.abs(thisGamepad.rightStick.y);\n\t\t\t\t\t\tthis.players[thisGamepad.index].direction_secondary.TIMESTAMP = this.scene.sys.time.now;\n\t\t\t\t\t} else if (thisGamepad.rightStick.y > 0.5) {\n\t\t\t\t\t\tthis.players[thisGamepad.index].direction_secondary.DOWN = thisGamepad.rightStick.y;\n\t\t\t\t\t\tthis.players[thisGamepad.index].direction_secondary.TIMESTAMP = this.scene.sys.time.now;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.players[thisGamepad.index].direction_secondary.UP = 0;\n\t\t\t\t\t\tthis.players[thisGamepad.index].direction_secondary.DOWN = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (thisGamepad.rightStick.x < -0.5) {\n\t\t\t\t\t\tthis.players[thisGamepad.index].direction_secondary.LEFT = Math.abs(thisGamepad.rightStick.x);\n\t\t\t\t\t\tthis.players[thisGamepad.index].direction_secondary.TIMESTAMP = this.scene.sys.time.now;\n\t\t\t\t\t} else if (thisGamepad.rightStick.x > 0.5) {\n\t\t\t\t\t\tthis.players[thisGamepad.index].direction_secondary.RIGHT = thisGamepad.rightStick.x;\n\t\t\t\t\t\tthis.players[thisGamepad.index].direction_secondary.TIMESTAMP = this.scene.sys.time.now;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.players[thisGamepad.index].direction_secondary.LEFT = 0;\n\t\t\t\t\t\tthis.players[thisGamepad.index].direction_secondary.RIGHT = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.players[thisGamepad.index].interaction.device === 'gamepad') {\n\t\t\t\t\t\t// Buttons\n\n\t\t\t\t\t\tfor (var b = 0; b < thisGamepad.buttons.length; b++) {\n\t\t\t\t\t\t\tvar button = thisGamepad.buttons[b];\n\t\t\t\t\t\t\tthis.players[thisGamepad.index].buttons['B' + b] = button.value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError10 = true;\n\t\t\t\t_iteratorError10 = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion10 && _iterator10.return) {\n\t\t\t\t\t\t_iterator10.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError10) {\n\t\t\t\t\t\tthrow _iteratorError10;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Function to run on pointer move.\n   * @param {*} pointer - The pointer object\n   */\n\n\t}, {\n\t\tkey: 'pointerMove',\n\t\tvalue: function pointerMove(pointer, threshold) {\n\t\t\tvar threshold = threshold || 0;\n\t\t\tif (pointer.distance > threshold) {\n\t\t\t\tvar pointerDirection = this.getBearingFromAngle(pointer.angle, 8);\n\t\t\t\t// this.players[0].direction_secondary = this.mapBearingToDirections(pointerDirection);\n\n\t\t\t\t// If we've been given a player position, return bearings and angles\n\t\t\t\tif (typeof this.players[0] !== 'undefined' && this.players[0].position.x !== 'undefined') {\n\t\t\t\t\tvar position = this.players[0].position;\n\t\t\t\t\tvar angleToPointer = Phaser.Math.Angle.Between(position.x, position.y, pointer.worldX, pointer.worldY);\n\t\t\t\t\tvar _pointerDirection = this.getBearingFromAngle(angleToPointer, 8);\n\t\t\t\t\tvar pointerAngle = Number(this.mapBearingToDegrees(_pointerDirection));\n\n\t\t\t\t\tthis.players[0].pointer.BEARING = _pointerDirection;\n\t\t\t\t\tthis.players[0].pointer.ANGLE = angleToPointer;\n\t\t\t\t\tthis.players[0].pointer.BEARING_DEGREES = pointerAngle;\n\t\t\t\t\tthis.players[0].pointer.TIMESTAMP = this.scene.sys.time.now;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Function to run on pointer down. Indicates that Mx has been pressed, which should be listened to by the player object\n   * @param {*} pointer - The pointer object\n   */\n\n\t}, {\n\t\tkey: 'pointerDown',\n\t\tvalue: function pointerDown(pointer) {\n\t\t\tvar action = '';\n\t\t\tthis.players[0].interaction.device = 'pointer';\n\t\t\tif (pointer.leftButtonDown()) {\n\t\t\t\taction = 'M1';\n\t\t\t}\n\t\t\tif (pointer.rightButtonDown()) {\n\t\t\t\taction = 'M2';\n\t\t\t}\n\t\t\tif (pointer.middleButtonDown()) {\n\t\t\t\taction = 'M3';\n\t\t\t}\n\t\t\tif (pointer.backButtonDown()) {\n\t\t\t\taction = 'M4';\n\t\t\t}\n\t\t\tif (pointer.forwardButtonDown()) {\n\t\t\t\taction = 'M5';\n\t\t\t}\n\n\t\t\tthis.eventEmitter.emit('mergedInput', { device: 'pointer', value: 1, player: 0, action: action, state: 'DOWN' });\n\n\t\t\tthis.players[0].pointer[action] = 1;\n\n\t\t\t// Update the last button state\n\t\t\tthis.players[0].interaction.pressed = action;\n\t\t\tthis.players[0].interaction.last = action;\n\t\t\tthis.players[0].interaction.buffer = action;\n\t\t\tthis.players[0].pointer.TIMESTAMP = pointer.moveTime;\n\t\t}\n\n\t\t/**\n   * Function to run on pointer up. Indicates that Mx has been released, which should be listened to by the player object\n   * @param {*} pointer - The pointer object\n   */\n\n\t}, {\n\t\tkey: 'pointerUp',\n\t\tvalue: function pointerUp(pointer) {\n\t\t\tvar action = '';\n\t\t\tif (pointer.leftButtonReleased()) {\n\t\t\t\taction = 'M1';\n\t\t\t}\n\t\t\tif (pointer.rightButtonReleased()) {\n\t\t\t\taction = 'M2';\n\t\t\t}\n\t\t\tif (pointer.middleButtonReleased()) {\n\t\t\t\taction = 'M3';\n\t\t\t}\n\t\t\tif (pointer.backButtonReleased()) {\n\t\t\t\taction = 'M4';\n\t\t\t}\n\t\t\tif (pointer.forwardButtonReleased()) {\n\t\t\t\taction = 'M5';\n\t\t\t}\n\n\t\t\tthis.eventEmitter.emit('mergedInput', { device: 'pointer', value: 1, player: 0, action: action, state: 'UP' });\n\n\t\t\tthis.players[0].pointer[action] = 0;\n\t\t\tthis.players[0].pointer.TIMESTAMP = this.scene.sys.time.now;\n\t\t}\n\n\t\t/**\n   * Get the bearing from a given angle\n   * @param {float} angle - Angle to use\n   * @param {number} numDirections - Number of possible directions (e.g. 4 for N/S/E/W)\n   */\n\n\t}, {\n\t\tkey: 'getBearingFromAngle',\n\t\tvalue: function getBearingFromAngle(angle, numDirections, threshold) {\n\t\t\tvar numDirections = numDirections || 8;\n\n\t\t\tvar snap_interval = Phaser.Math.PI2 / numDirections;\n\n\t\t\tvar angleSnap = Phaser.Math.Snap.To(angle, snap_interval);\n\t\t\tvar angleSnapDeg = Phaser.Math.RadToDeg(angleSnap);\n\t\t\tvar angleSnapDir = this.bearings[angleSnapDeg];\n\n\t\t\treturn angleSnapDir;\n\t\t}\n\n\t\t/**\n   * Given a bearing, return a direction object containing boolean flags for the four directions\n   * @param {*} bearing\n   */\n\n\t}, {\n\t\tkey: 'mapBearingToDirections',\n\t\tvalue: function mapBearingToDirections(bearing) {\n\t\t\tvar thisDirection = {\n\t\t\t\t'UP': 0,\n\t\t\t\t'DOWN': 0,\n\t\t\t\t'LEFT': 0,\n\t\t\t\t'RIGHT': 0,\n\t\t\t\t'BEARING': bearing.toUpperCase()\n\t\t\t};\n\n\t\t\tif (bearing.toUpperCase().includes('W')) {\n\t\t\t\tthisDirection.LEFT = 1;\n\t\t\t}\n\t\t\tif (bearing.toUpperCase().includes('E')) {\n\t\t\t\tthisDirection.RIGHT = 1;\n\t\t\t}\n\t\t\tif (bearing.toUpperCase().includes('S')) {\n\t\t\t\tthisDirection.DOWN = 1;\n\t\t\t}\n\t\t\tif (bearing.toUpperCase().includes('N')) {\n\t\t\t\tthisDirection.UP = 1;\n\t\t\t}\n\n\t\t\treturn thisDirection;\n\t\t}\n\n\t\t/**\n   * Given a directions object, return the applicable bearing (8 way only)\n   * @param {*} directions\n   */\n\n\t}, {\n\t\tkey: 'mapDirectionsToBearing',\n\t\tvalue: function mapDirectionsToBearing(directions, threshold) {\n\t\t\tvar threshold = threshold || -.5;\n\t\t\tif (directions.UP && !(directions.LEFT || directions.RIGHT)) {\n\t\t\t\treturn 'N';\n\t\t\t}\n\t\t\tif (directions.RIGHT && directions.UP) {\n\t\t\t\treturn 'NE';\n\t\t\t}\n\t\t\tif (directions.RIGHT && !(directions.UP || directions.DOWN)) {\n\t\t\t\treturn 'E';\n\t\t\t}\n\t\t\tif (directions.RIGHT && directions.DOWN) {\n\t\t\t\treturn 'SE';\n\t\t\t}\n\t\t\tif (directions.DOWN && !(directions.LEFT || directions.RIGHT)) {\n\t\t\t\treturn 'S';\n\t\t\t}\n\t\t\tif (directions.LEFT && directions.DOWN) {\n\t\t\t\treturn 'SW';\n\t\t\t}\n\t\t\tif (directions.LEFT && !(directions.UP || directions.DOWN)) {\n\t\t\t\treturn 'W';\n\t\t\t}\n\t\t\tif (directions.LEFT && directions.UP) {\n\t\t\t\treturn 'NW';\n\t\t\t}\n\t\t\treturn '';\n\t\t}\n\n\t\t/**\n   * Given a bearing, return the snapped angle in degrees\n   * @param {*} bearing\n   */\n\n\t}, {\n\t\tkey: 'mapBearingToDegrees',\n\t\tvalue: function mapBearingToDegrees(bearing) {\n\t\t\tvar _this2 = this;\n\n\t\t\tif (bearing != '') {\n\t\t\t\treturn Object.keys(this.bearings).find(function (key) {\n\t\t\t\t\treturn _this2.bearings[key] === bearing;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'destroy',\n\t\tvalue: function destroy() {\n\t\t\tthis.shutdown();\n\t\t\tthis.scene = undefined;\n\t\t}\n\n\t\t/**\n   * Return debug object\n   */\n\n\t}, {\n\t\tkey: 'debug',\n\t\tvalue: function debug() {\n\t\t\t// Debug variables\n\t\t\tvar debug = {\n\t\t\t\t'input': {}\n\t\t\t};\n\t\t\tdebug.input.gamepads = [];\n\t\t\tfor (var i = 0; i < this.gamepads.length; i++) {\n\t\t\t\tvar pad = this.gamepads[i];\n\t\t\t\tvar buttons = {};\n\t\t\t\tvar axes = {};\n\n\t\t\t\tfor (var b = 0; b < pad.buttons.length; b++) {\n\t\t\t\t\tvar button = pad.buttons[b];\n\t\t\t\t\tbuttons['B' + button.index] = button.value;\n\t\t\t\t}\n\n\t\t\t\tfor (var a = 0; a < pad.axes.length; a++) {\n\t\t\t\t\tvar axis = pad.axes[a];\n\t\t\t\t\taxes['A' + axis.index] = axis.getValue();\n\t\t\t\t}\n\n\t\t\t\tdebug.input.gamepads.push({\n\t\t\t\t\t'ID': pad.id,\n\t\t\t\t\t'Index': pad.index,\n\t\t\t\t\t'Buttons': buttons,\n\t\t\t\t\t'Axes': axes\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tdebug.players = [];\n\t\t\tvar _iteratorNormalCompletion11 = true;\n\t\t\tvar _didIteratorError11 = false;\n\t\t\tvar _iteratorError11 = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator11 = this.players[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n\t\t\t\t\tvar thisPlayer = _step11.value;\n\n\t\t\t\t\tdebug.players.push({\n\t\t\t\t\t\t'interaction': thisPlayer.interaction,\n\t\t\t\t\t\t'device': thisPlayer.device,\n\t\t\t\t\t\t'buttons': thisPlayer.buttons,\n\t\t\t\t\t\t'pointer': thisPlayer.pointer,\n\t\t\t\t\t\t'direction': thisPlayer.direction,\n\t\t\t\t\t\t'direction_secondary': thisPlayer.direction_secondary,\n\t\t\t\t\t\t'keys': thisPlayer.keys\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError11 = true;\n\t\t\t\t_iteratorError11 = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion11 && _iterator11.return) {\n\t\t\t\t\t\t_iterator11.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError11) {\n\t\t\t\t\t\tthrow _iteratorError11;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn debug;\n\t\t}\n\t}]);\n\n\treturn MergedInput;\n}(Phaser.Plugins.ScenePlugin);\n\nexports.default = MergedInput;"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;A","sourceRoot":""}